#version 430 core
uniform vec2 Resolution;

uniform float iTime;

uniform vec3 viewPosWS;
uniform float near_plane;
uniform float far_plane;

//��׼����
uniform vec3 baseColor;
uniform float metallic;
uniform float roughness;
uniform float reflectance;
uniform vec3 emissive;


uniform sampler2D texture_albedo1;
uniform sampler2D texture_normal1;


//��ɫ��ӳ��
//diffuse color
vec3 BaseColorReMap(vec3 color, float metallic)
{
    return (1.0 - metallic) * color;
}

//��������ӳ��
//Fresnel��������f0�����ҶԵ���ʶ����ǵ�ɫ��
vec3 ReflectanceReMap(float reflec)
{
    return 0.16 * reflec * reflec;
}

//���������ʼ���Fresnel������f0
float GetF0WithIOR(float n)
{
    float a = n - 1.0;
    float b = n + 1.0;
    return a * a / (b * b);
}

//����̣�����f0����������
float GetIORWithF0(float f0)
{
    float a = 1.0 - sqrt(f0);
    return 2.0 / a - 1.0;
}


//��ȡF90�������棬һ����1
float GetF90_C()
{
    return 1.0;
}


//�������ʺͽ������ʵ�f0, ���淴�����ɫ���Խ����Ļ�ɫ
vec3 GetF0_All(vec3 base_color, float metal, float reflec)
{
    return ReflectanceReMap(reflec) * (1.0 - metal) + base_color * metal;
}


//�ֲڶ���ӳ�� 
//a = roughness * roughness
float RoughnessReMap(float rough)
{
    return rough * rough;
}

#define PI 3.14159265358
#define PI_INV 0.31830988618
#define HALF_PI (0.5 * PI)
#define PI2 6.28318530
#define GAMMA 0.4545454545


// Range remapping from [0, 1] to [-1, 1].
// ...
float RemapNDC(float a)
{
    return a * 2.0 - 1.0;
}

// Get Linear depth.
// ...
float LinearizeDepth(float depth, float near, float far)
{
    float z = RemapNDC(depth);
    return (2.0 * near * far) / (far + near - z * (far - near));
    
}

// AlphaTest
// ...
float AlphaTest(float alpha, float min_)
{
    if (alpha < min_)
        discard;
    return 1.0;
}

// Gamma Correction
// ...
vec3 GammaCorrection(vec3 color)
{
    return pow(color, vec3(GAMMA));
}

// Random Creation.
// We do not use Trigonometric function.
// ...
// -----------------------------------------------------
//  1 out, 1 in...
float hash11(float p)
{
    //p = fract(p * .1031);
    //p *= p + 33.33;
    //p *= p + p;
    //return fract(p);
    return fract(sin(p) * 10000.0);
}

//----------------------------------------------------------------------------------------
//  1 out, 2 in
// ...
float hash12(vec2 uv)
{
	//vec3 p3  = fract(vec3(p.xyx) * .1031);
    //p3 += dot(p3, p3.yzx + 33.33);
    //return fract((p3.x + p3.y) * p3.z);

    const float a = 12.9898, b = 78.233, c = 43758.5453;
    float dt = dot(uv.xy, vec2(a, b)), sn = mod(dt, PI);
    return fract(sin(sn) * c);
}

//----------------------------------------------------------------------------------------
//  1 out, 3 in
// ...
float hash13(vec3 p3)
{
	p3  = fract(p3 * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

//----------------------------------------------------------------------------------------
//  2 out, 1 in
// ...
vec2 hash21(float p)
{
	vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));
	p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.xx+p3.yz)*p3.zy);

}

//----------------------------------------------------------------------------------------
///  2 out, 2 in
// ...
vec2 hash22(vec2 p)
{
	vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yzx+33.33);
    return fract((p3.xx+p3.yz)*p3.zy);

}

//----------------------------------------------------------------------------------------
///  2 out, 3 in
// ...
vec2 hash23(vec3 p3)
{
	p3 = fract(p3 * vec3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yzx+33.33);
    return fract((p3.xx+p3.yz)*p3.zy);
}

//----------------------------------------------------------------------------------------
//  3 out, 1 in
// ...
vec3 hash31(float p)
{
   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));
   p3 += dot(p3, p3.yzx+33.33);
   return fract((p3.xxy+p3.yzz)*p3.zyx); 
}


//----------------------------------------------------------------------------------------
///  3 out, 2 in
// ...
vec3 hash32(vec2 p)
{
	vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yxz+33.33);
    return fract((p3.xxy+p3.yzz)*p3.zyx);
}

//----------------------------------------------------------------------------------------
///  3 out, 3 in
// ...
vec3 hash33(vec3 p3)
{
	p3 = fract(p3 * vec3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yxz+33.33);
    return fract((p3.xxy + p3.yxx)*p3.zyx);

}

//----------------------------------------------------------------------------------------
// 4 out, 1 in
// ...
vec4 hash41(float p)
{
	vec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));
    p4 += dot(p4, p4.wzxy+33.33);
    return fract((p4.xxyz+p4.yzzw)*p4.zywx);
    
}

//----------------------------------------------------------------------------------------
// 4 out, 2 in
// ...
vec4 hash42(vec2 p)
{
	vec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));
    p4 += dot(p4, p4.wzxy+33.33);
    return fract((p4.xxyz+p4.yzzw)*p4.zywx);

}

//----------------------------------------------------------------------------------------
// 4 out, 3 in
// ...
vec4 hash43(vec3 p)
{
	vec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));
    p4 += dot(p4, p4.wzxy+33.33);
    return fract((p4.xxyz+p4.yzzw)*p4.zywx);
}

//----------------------------------------------------------------------------------------
// 4 out, 4 in
// ...
vec4 hash44(vec4 p4)
{
	p4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));
    p4 += dot(p4, p4.wzxy+33.33);
    return fract((p4.xxyz+p4.yzzw)*p4.zywx);
}


// IQ Noise
// ...
float noise31_IQ(vec3 rp)
{
    vec3 ip = floor(rp);
    rp -= ip;
    vec3 s = vec3(7, 157, 113);
    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);
    rp = rp * rp * (3.0 - 2.0 * rp);
    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);
    h.xy = mix(h.xz, h.yw, rp.y);
    return mix(h.x, h.y, rp.z);
}

// FBM v1
// Base.
// ...
float fbm_v1(vec3 x)
{
    float r = 0.0;
    float w = 1.0;
    float s = 1.0;
    for(int i = 0; i < 5; i++)
    {
        w *= 0.5;
        s *= 2.0;
        r += w * noise31_IQ(s * x);
    }
    return r;
}

// FBM v2
// ...
float fbm_v2(vec3 x, float H, int numOctaves)
{
    float G = exp2(-H);
    float f = 1.0;
    float a = 1.0;
    float t = 0.0;
    for(int i = 0; i < numOctaves; ++i)
    {
        t += a * noise31_IQ(f * x);
        f *= 2.0;
        a *= G;
    }
    return t;
}


// Some useful math functions.
// ...
// ---------------------------------------------------
// ---------------------------------------------------

float Gain_11(float x, float k)
{
    float a = 0.5 * pow(2.0 * ((x < 0.5) ? x : 1.0 - x), k);
    return (x < 0.5) ? a : 1.0 - a;
}

vec3 Gain_33(vec3 x, float k)
{
    return vec3(Gain_11(x.x, k), Gain_11(x.y, k), Gain_11(x.z, k));
}

// L2 Paradigm
// ...
float L2(float x, float y){
    return sqrt(x * x + y * y);
}

// Max function with 4 items.
// ...
float max4(float l1,float l2, float l3, float l4){
    return max(max(l1, l2), max(l3, l4));
}

// Judge function.
// if in > 0.0, return 0.0.
// else return 1.0.
// ...
float l(float y){
    if(y < 0.0)return 1.0;
    return 0.0;
}

// Right atan.
// ...
float atan2(float x, float y){
    if(x > 0.)return atan(y/x);
    if(x < 0. && y >= 0.) return atan(y/x) + PI;
    if(x < 0. && y < 0.) return atan(y/x) - PI;
    if(x == 0. && y > 0.) return HALF_PI;
    if(x == 0. && y < 0.) return -1. * HALF_PI;
    return 0.0;
}

// Judge uv in range [0, 1].
// ...
float inRange(vec2 uv){
    if(uv.x < 0.0 || uv.x > 1.0)return -1.0;
    if(uv.y < 0.0 || uv.y > 1.0)return -1.0;
    return 1.0;
}



// Foveated Rendering
// ...
uniform vec2 LowResolution;

#define W Resolution.x
#define H Resolution.y
#define w LowResolution.x
#define h LowResolution.y

// Kernel function.
// ...
float K(float a){
    //return a * a;
    return a;
    return 0.99 * a + 0.01 * a * a;
    return sin(a * PI / 2.);
    return 0.5 * a + 0.5 * a * a;
}

// Inv kernel function.
// ...
float K_inv(float a){
   // return sqrt(a);
    return a;
}

// Get Fovea Point
// ...
vec2 getFovea(){
    return Resolution.xy /2.;
    //return iMouse.xy;
}

// Tool function for fovea
// ...
float getL(){
    float x = getFovea().x;
    float y = getFovea().y;
    
    float l1 = L2(x ,y);
    float l2 = L2(W - x, H - y);
    float l3 = L2(x, H - y);
    float l4 = L2(W - x, y);
    return log(max4(l1, l2, l3, l4));
}


// Foveated Algorithm --- Pass 1.
// ...
vec3 FoveatedRendering_Pass_1(sampler2D frame, vec2 uv)
{
    uv = uv * Resolution;

    float L = getL();
    float A = L / w;
    float B = PI2 / h;
    
    float k_u = K(uv.x / w) * w;
    float A_K_u = A * k_u;
    A_K_u = exp(A_K_u);
    
    float b_v = B * uv.y;
    float cos_b = cos(b_v);
    float sin_b = sin(b_v);
    
    float x = A_K_u * cos_b + getFovea().x;
    float y = A_K_u * sin_b + getFovea().y;
    
    uv = vec2(x / w, y / h);
    
    vec3 col = texture(frame, uv).xyz;
    
    if(inRange(uv) < 0.0)col = vec3(0. ,0. ,0.);

  //  return vec3(h);
    return col;
}

vec3 FoveatedRendering_Pass_2(sampler2D frame, vec2 uv)
{
    uv = uv * Resolution;

    uv = uv - getFovea();
    
    float dis = L2(uv.x, uv.y);
    float L = getL();
    dis = log(dis) / L;
    
    float x = K_inv(dis) * w;
    
    float arcyx = atan2(uv.x, uv.y);
    
    float y = arcyx + l(uv.y) * PI2;
    y = y * h / (PI2);
    
    
    uv = vec2(x / w, y / h);
    
    vec3 col = texture(frame, uv).xyz;
    
    if(inRange(uv) < 0.0)col = vec3(0. ,0. ,0.);

    //return vec3(h);
    return col;
}


out vec4 FragColor;

in vec2 TexCoords;

uniform sampler2D screenTexture;

void main()
{
    vec3 col = FoveatedRendering_Pass_2(screenTexture, TexCoords);
    FragColor = vec4(col.rgb, 1.0);
} 